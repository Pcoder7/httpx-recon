name: Parallel HTTPX Probe

on:
  workflow_dispatch:

permissions:
  contents: write

env:
  LINES_PER_CHUNK: 100     # <— maximum lines per file
  MAX_PARALLEL: 5         # <— throttle HTTPX jobs

jobs:
  prepare_matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set_matrix.outputs.matrix }}
      unique_domains: ${{ steps.set_matrix.outputs.unique_domains }}
    steps:
      - uses: actions/checkout@v3
        with: { fetch-depth: 0 }
      - name: Build domain matrix from results/*/all_resolved.txt
        id: set_matrix
        run: |
          # 1. Discover directories under results/ that contain all_resolved.txt
          mapfile -t domains < <(
            find results -mindepth 1 -maxdepth 1 -type d \
              -exec test -f "{}/all_resolved.txt" \; -print \
            | sed 's|results/||'
          )

          # 2. If no domains are found, emit an empty matrix
          if [ ${#domains[@]} -eq 0 ]; then
            echo "No domains found under results/ — emitting empty matrix."
            matrix_json="[]"
          else
            # 3. Build a JSON array of objects: { "domain": "<name>" }
            entries=()
            for d in "${domains[@]}"; do
              entries+=( "{\"domain\":\"$d\"}" )
            done
            matrix_json="[${entries[*]}]"
          fi

          # 4. Emit domain matrix as a multi-line GitHub Actions output
          {
            echo "matrix<<MATRIX_EOF"
            echo "${matrix_json}"
            echo "MATRIX_EOF"
          } >> "$GITHUB_OUTPUT"

          # 5. Emit pure domain list as JSON array
          domains_json=$(printf '%s\n' "${domains[@]}" | jq -R . | jq -s .)
          {
            echo "unique_domains<<DOMAINS_EOF"
            echo "${domains_json}"
            echo "DOMAINS_EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Upload chunks artifact
        uses: actions/upload-artifact@v4
        with:
          name: httpx-chunks
          path: chunks
  
  httpx:
    needs: prepare_matrix
    runs-on: ubuntu-latest
    if: ${{ needs.prepare_matrix.outputs.matrix != '[]' }}
    strategy:
      matrix:
        pair: ${{ fromJson(needs.prepare_matrix.outputs.matrix) }}
      max-parallel: 15

    steps:
      - uses: actions/checkout@v3

      - name: Cache Go modules & binaries
        uses: actions/cache@v3
        with:
          path: |
            $HOME/go/pkg/mod
            ~/.cache/go-build
            $HOME/go/bin
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}-tools
          restore-keys: |
            ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}-

      - name: Setup Go (for go install)
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Ensure httpx & anew are installed
        run: |
          if ! command -v httpx >/dev/null; then
            go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest
          else
            echo "httpx already cached"
          fi
          if ! command -v anew >/dev/null; then
            go install -v github.com/tomnomnom/anew@latest
          else
            echo "anew already cached"
          fi

      - name: Download chunk files
        uses: actions/download-artifact@v4
        with: 
          name: httpx-chunks 
          path: chunks 

      - name: Probe with httpx on ${{ matrix.pair.domain }}
        run: |
         
          D="${{ matrix.domain }}"
          SRC="results/${D}/all_resolved.txt"
          if [ ! -f "$SRC" ]; then
            echo "Missing input file: $SRC" >&2
            exit 1
          fi
      
          # Create a per-domain chunks directory
          mkdir -p "chunks/${D}"
          split -l 100 --numeric-suffixes=1 --suffix-length=2 \
                "$SRC" "chunks/${D}/chunk_"
      
          # Create an output directory for this domain
          mkdir -p "httpx_out/${D}"
      
          # Loop over each chunk file
          for CH in chunks/"${D}"/chunk_*; do
            httpx -l "$CH" -silent -threads 50 \
              -o httpx_out/"${D}"/httpx_"$(basename "$CH")".txt
          done
          
      - name: Upload per‑chunk httpx results
        uses: actions/upload-artifact@v4
        with:
          name: httpx-${{ matrix.pair.domain }}
          path: httpx_out/${{ matrix.pair.domain }}/httpx_*.txt

  aggregate_results:
    needs: [prepare_matrix, httpx]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        domain: ${{ fromJson(needs.prepare_matrix.outputs.unique_domains) }}
    steps:
      - uses: actions/checkout@v3
        with: { fetch-depth: 0 }

      - name: Cache Go modules & binaries
        uses: actions/cache@v3
        with:
          path: |
            $HOME/go/pkg/mod
            ~/.cache/go-build
            $HOME/go/bin
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}-tools
          restore-keys: |
            ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}-

      - name: Setup Go (for go install)
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'       

      - name: Ensure anew is installed
        run: |
          if ! command -v anew >/dev/null; then
            echo "Installing anew…"
            go install github.com/tomnomnom/anew@latest
          else
            echo "anew already cached"
          fi          

      - name: Download all httpx artifacts
        uses: actions/download-artifact@v4

      - name: Aggregate for ${{ matrix.domain }}
        run: |
          D="${{ matrix.domain }}"
          # make sure domain dir exists (matches chunks and recon)
          mkdir -p results/"$D"

          # cat only this domain’s httpx files
          cat httpx_out/"$D"/httpx_*.txt \
            | anew -q results/"$D"/httpx_result.txt

      - name: Commit & push HTTPX result for ${{ matrix.domain }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "actions@github.com"

          TARGET="results/${{ matrix.domain }}/httpx_result.txt"
          git add "$TARGET"
          git diff --cached --quiet || git commit -m "HTTPX result for ${{ matrix.domain }}"
          git pull --rebase --autostash origin main
          git push origin HEAD:main
          git pull --rebase --autostash
          git push            
