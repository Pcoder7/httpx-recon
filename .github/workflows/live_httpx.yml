name: Parallel HTTPX Probe

on:
  workflow_dispatch:
    inputs:
      results_repo:
        type: string
        required: true
      artifact_name:
        type: string
        required: true

permissions:
  contents: write

env:
  RESULTS_REPO: ${{ github.event.inputs.results_repo }}

  LINES_PER_CHUNK: 100     # <— maximum lines per file
  MAX_PARALLEL: 10         # <— throttle HTTPX jobs


jobs:
  prepare_matrix:
    runs-on: ubuntu-latest
   
    outputs:
      matrix: ${{ steps.set_matrix.outputs.matrix }}
      unique_domains: ${{ steps.set_matrix.outputs.unique_domains }}
     
    steps:
      - name: Checkout Repository      
        uses: actions/checkout@v3
        with: 
          fetch-depth: 0 

      - name: Print Inputs (debug)
        run: |
          echo "Results Repo: $RESULTS_REPO"
          echo "Artifact Name: ${{ github.event.inputs.artifact_name }}"
       

      - name: Download recon-results artifact from upstream repo
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          echo "Attempting to download artifact: ${{ github.event.inputs.artifact_name }} from repo: ${{ env.RESULTS_REPO }}"         
          gh run download \
            --repo "${{ env.RESULTS_REPO }}" \
            --name "${{ github.event.inputs.artifact_name }}" \
            --dir results    

          echo "Download complete. Checking contents of workspace and results directory:"
          pwd
          ls -lA
          echo "--- Contents of results directory ---"
          ls -R results
       
      - name: Debug list downloaded files and structure
        run: |
          echo "Current directory structure:"
          ls -R .
          echo "Specifically, contents of ./results:"
          if [ -d "results" ]; then
            ls -R results
          else
            echo "./results directory does not exist."
          fi
        
        #- name: Flatten recon-results artifact structure
         # run: |
         #  ART="${{ github.event.inputs.artifact_name }}"
         # # Move the inner results/<domain> dirs up into results/
          #mv "results/${ART}/results"/* results/
          # Clean up the now-empty artifact wrapper
          #rm -rf "results/${ART}"

          
      - name: Build domain matrix from results/*/all_resolved.txt
        id: set_matrix
        run: |
          # 1. Discover domain folders with all_resolved.txt
          mapfile -t domains < <(
            find results -mindepth 1 -maxdepth 1 -type d \
              -exec test -f "{}/all_resolved.txt" \; -print \
            | sed -e 's|results/||'
          )
      
          # 2. If no domains are found, emit an empty matrix
          if [ ${#domains[@]} -eq 0 ]; then
            echo "No domains found under results/ — emitting empty matrix."
            echo "matrix<<EOF" >> $GITHUB_OUTPUT
            echo "[]"           >> $GITHUB_OUTPUT
            echo "EOF"          >> $GITHUB_OUTPUT
          else
            pairs=()
      
            for d in "${domains[@]}"; do
              SRC="results/$d/all_resolved.txt"
      
              # 3. Create per-domain chunk dir & split into 100-line files
              CHUNK_DIR="results/$d/chunks"
              mkdir -p "$CHUNK_DIR"
              split -l 100 --numeric-suffixes=1 --suffix-length=2 \
                    --additional-suffix=.txt \
                    "$SRC" "$CHUNK_DIR/chunk_"
      
              # 4. Debug: list out what we just created
              echo "Contents of $CHUNK_DIR:"
              ls -R "$CHUNK_DIR" || echo "(none found)"
      
              # 5. Build a JSON pair for each chunk file
              for CH in "$CHUNK_DIR"/chunk_*; do
                pairs+=( "{\"domain\":\"$d\",\"chunk\":\"$CH\"}" )
              done
            done
      
            # 6. Emit the chunk-level matrix
            echo "matrix<<EOF" >> $GITHUB_OUTPUT
            printf '%s\n' "${pairs[@]}" | jq -s . >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
      
          # 7. Emit the unique domain list (unchanged)
          domains_json=$(printf '%s\n' "${domains[@]}" | jq -R . | jq -s .)
          {
            echo "unique_domains<<EOF"
            echo "${domains_json}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"    
                

      - name: Upload chunks artifact
        uses: actions/upload-artifact@v4
        with:
          name: httpx-chunks
          path: results/*/chunks/**
  
  httpx:
    needs: prepare_matrix
    runs-on: ubuntu-latest
    if: ${{ needs.prepare_matrix.outputs.matrix != '[]' }}
    strategy:
      matrix:
        pair: ${{ fromJson(needs.prepare_matrix.outputs.matrix) }}
      max-parallel: 10

    steps:
    
      - name: Setup Go (for go install)
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
          
      - uses: actions/checkout@v3
      - name: Create mod cache directory
        run: mkdir -p $HOME/go/pkg/mod
      
      - name: Cache Go binaries (httpx, anew)
        uses: actions/cache@v3
        with:
          path: |
            $HOME/go/pkg/mod
             ~/.cache/go-build
             $HOME/go/bin
          key: go-cache-${{ github.ref_name }} 
          restore-keys: |
            go-cache-



      - name: Ensure httpx & anew are installed
        run: |
         
          if ! command -v httpx >/dev/null; then
            go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest
            echo "httpx installed"
            find $HOME -name httpx -type f
            echo "find actually found httpx path"
            
          else
            echo "httpx already cached"
          fi
          if ! command -v anew >/dev/null; then
            go install -v github.com/tomnomnom/anew@latest
            
          else
            echo "anew already cached"
          fi
          echo "ls -R . show"
          ls -R .
          echo "\n\n\n ----"


      - name: Download chunk files
        uses: actions/download-artifact@v4
        with: 
          name: httpx-chunks 
          path: results/
      
      #- name: List chunk files
       # run: |
        #  D="${{ matrix.pair.domain }}"
         # echo "Contents of results/${D}/chunks:"
          #ls -R "results/${D}/chunks"
      
      - name: Probe with httpx on ${{ matrix.pair.domain }}
        run: |
       
          D="${{ matrix.pair.domain }}"
          CH="${{ matrix.pair.chunk }}"
          OUT="results/${D}/httpx_out"
          mkdir -p "$OUT"

          echo "▶ Probing chunk: $CH"
          httpx -l "$CH" -silent -threads 50 \
            -o "${OUT}/httpx_$(basename "$CH").txt"
      
      - name: Compute per-chunk artifact name
        id: art
        run: |
          D="${{ matrix.pair.domain }}"
          CHN="$(basename "${{ matrix.pair.chunk }}")"
          # this writes an output called 'artifact_name'
          echo "artifact_name=httpx-${D}-${CHN}" >> $GITHUB_OUTPUT
          ANAME="httpx-${D}-${CHN}"

           # debug output so you can see it in the log
          echo ">> DEBUG: artifact_name is '$ANAME'"
            
          
      - name: Upload per‑chunk httpx results
        uses: actions/upload-artifact@v4
        env:
          ART_NAME: ${{ steps.art.outputs.artifact_name }}
        with:
          name: ${{ env.ART_NAME }}
          path: results/${{ matrix.pair.domain }}/httpx_out/*.txt


  aggregate_results:
    needs: [prepare_matrix, httpx]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        domain: ${{ fromJson(needs.prepare_matrix.outputs.unique_domains) }}
    steps:
      - uses: actions/checkout@v3
        with: { fetch-depth: 0 }

      - name: Cache Go modules & binaries
        uses: actions/cache@v3
        with:
          path: |
            $HOME/go/pkg/mod
            ~/.cache/go-build
            $HOME/go/bin
          key: go-cache-${{ github.ref_name }}
          restore-keys: |
            go-cache-

      - name: Setup Go (for go install)
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'       

      - name: Ensure anew is installed
        run: |
          if ! command -v anew >/dev/null; then
            echo "Installing anew…"
            go install github.com/tomnomnom/anew@latest
          else
            echo "anew already cached"
          fi          

      - name: Download all httpx artifacts
        uses: actions/download-artifact@v4
        with:
          path: results

      - name: Aggregate for ${{ matrix.domain }}
        run: |
          D="${{ matrix.domain }}"
          # make sure domain dir exists (matches chunks and recon)
          mkdir -p results/"$D"/httpx_out
          ls -A results
                            
          # cat only this domain’s httpx files
             # show how many lines we actually have across all the chunk files:
          echo "Total lines across chunks:"
          find results -type f -path "*/httpx-${D}-chunk_*.txt" -print0 | xargs -0 cat | tee >(wc -l)
          
           # now dedupe into one file
          echo "deduping files"
          find results -type f -path "*/httpx-${D}-chunk_*.txt" -print0 | xargs -0 cat | sort -u > results/"$D"/httpx_result.txt
          wc -l results/"$D"/httpx_result.txt

      - name: Push HTTPX results to store-recon
        # run in the same job where matrix.domain and results/ already exist
        env:
          PAT: ${{ secrets.STORE_RECON_CAT }}
          DOMAIN: ${{ matrix.domain }}
          TARGET_REPO: pushrockzz/store-recon
        run: |
          set -e

          # 1) Configure Git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "actions@github.com"

          # 2) Clone store-recon (shallow)
          git clone https://x-access-token:${PAT}@github.com/${TARGET_REPO}.git \
            --depth 1 store-recon
          cd store-recon

          # 3) Copy over your results folder
          mkdir -p results/${DOMAIN}
          cp -r ../results/${DOMAIN}/* results/${DOMAIN}/

          # 4) Commit if there are changes
          git add results/${DOMAIN}
          if git diff --cached --quiet; then
            echo "No changes to commit for ${DOMAIN}"
            exit 0
          fi
          git commit -m "Add HTTPX results for ${DOMAIN}"

          # 5) Push with retry to handle rare race conditions
          ATTEMPTS=0
          MAX=5
          until [ $ATTEMPTS -ge $MAX ]; do
            git pull --rebase origin main && \
            git push origin HEAD:main && break
            ATTEMPTS=$((ATTEMPTS+1))
            echo "Push failed, retry $ATTEMPTS/$MAX..."
            sleep $((2 ** ATTEMPTS))
            git fetch origin main
          done
          if [ $ATTEMPTS -ge $MAX ]; then
            echo "❌ Failed to push after $MAX attempts"
            exit 1
          fi
